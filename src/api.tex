\subsection{The Measurement Library}
\label{ss:dataflow}

NetMap uses a dedicated server for collecting and storing the performance
measurements (see figure \ref{fig:servers}), so game developers do not need to
worry about securely storing and forwarding the sensitive data, and do not need
to provision for the bandwidth required by the data uploads.

\begin{figure}[hbtp]
  \center{\includegraphics[width=85mm]{figures/servers.pdf}}
  \caption{
    The NetMap platform has a dedicated server for storing network
    performance measurements, and the data is analyzed offline.
  }
  \label{fig:servers}
\end{figure}

The NetMap platform includes an Android library that manages the
straight-forward (but tedious) aspects of measuring network performance and
uploading the data to the NetMap server. We envision that when a player takes
an action in a game, the game code will call our library and ask it to collect
a performance measurement. Powerful moves (such as firing a very powerful
weapon) would trigger the collection of more battery-intensive measurements.
The measurement data is not uploaded to the NetMap
right away, so that the game can use all the player's (potentially limited)
wireless Internet bandwidth, so that the data upload is not charged against
the player's cellular Internet data quotas, and so that we do not burden the
player's mobile device battery. Instead, we queue up the data in a SQLite
database on the player's device, and we wait until the device is connected to a
WiFi network and its charger is plugged in. Under the right circumstances, all
the data queued up in SQLite is uploaded to the measurement server.


\begin{figure}[hbtp]
  \center{\includegraphics[width=85mm]{figures/dataflow.pdf}}
  \caption{
    The flow of measurement data inside a game client
  }
  \label{fig:dataflow}
\end{figure}

Table \ref{table:api} shows the API exposed by the NetMap measurements library
to the game client code. The \texttt{measure} and \texttt{upload} methods
perform the operations described above, while \texttt{powerSource} and
\texttt{networkSource} help the game client decide when to upload the queued
measurement data to the NetMap server. We expect that most game clients will
upload data when the phone is using a charger and a WiFi network.

\begin{table}[hbtp]
\begin{tabular}{|p{6.25cm}|p{1.5cm}|}
\hline
\textbf{class NetMap}\\
\hline
\hline
measure(\textbf{String} \textit{what}) : String \textit{digest}\\
\hline
upload() : \textbf{boolean} \textit{hasMoreData}\\
\hline
\hline
powerSource() : \textbf{PowerSource}\\
\hline
networkSource() : \textbf{NetworkSource}\\
\hline
location() : \textbf{Location}\\
\hline
\hline
initialize(\textbf{Context} \textit{androidContext})\\
\hline
configure(\textbf{String} \textit{userToken})\\
\hline
trackLocation(\textbf{Boolean} \textit{enabled})\\
\hline
\end{tabular}
\caption{
  The NetMap measurement library API
}
\label{table:api}
\end{table}

The performance measurements are tied to the user's location, so we ask game
clients to call \texttt{trackLocation(\textbf{true})} before performing network
measurements. In return, game code can call \texttt{location} to obtain the
user's location, and game developers do not need to implement their own
location tracking code. We expect that most game clients will call
\texttt{trackLocation(\textbf{true})} when their UI becomes the foreground
activity, and will call \texttt{trackLocation(\textbf{false})} when the game UI
loses the player's focus. This approach supplies location-based games with the
information they need for their UI, and ensures that measurements will have
fresh location information. To be on the safe side, the NetMap analytics code
discards measurements whose location timestamp is significantly older than the
measurement timestamp.

The API also includes asynchronous variants of \texttt{measure} and
\texttt{upload}, an evented interface for changes to \texttt{powerSource},
\texttt{networkSource} and \texttt{location}, as well as JSON-producing
variants of the last 3 functions, for easy integration with JavaScript.

\subsection{The NetMap Server}

The network performance measurement data collected by the NetMap library is
uploaded to the NetMap server, which stores the data for future analysis. We
hope and expect that all the games using the NetMap platform will upload their
measurements to our server. However, our library has an option of changing the
upload server URL, to facilitate game development.

The NetMap server tracks the game that uploaded each piece of measurement data,
and can provide a leaderboard that shows which games have contributed the most
to the network map. Game developers register the information in Table
\ref{table:metrics-app} with the NetMap server and receive an application ID
and secret HMAC key, which they use according to Figure \ref{fig:user-token}
to issue tokens for their players. A user token uniquely identifies the game
and the user that created the measurement, and a game cannot issue tokens on
behalf of another game without knowing its secret key. This allows the NetMap
server to discard a player's data, if the player is found cheating. Our
platform can also discard an entire game's data, if there are signs that the
game code is misbehaving.

\begin{table}[hbtp]
\begin{tabular}{|p{2.00cm}|p{5.50cm}|}
\hline
\textbf{Name} & user-friendly name for leaderboards \\
\hline
\textbf{Backend} & HTTP URL that receives callbacks \\
\hline
\textbf{Email} & developer contact information \\
\hline
\hline
\textbf{App ID} & unique identifier for an application \\
\hline
\textbf{App Secret} & HMAC key \\
\hline
\end{tabular}
\caption{
  Per-application data maintained by the NetMap server. A game developer
  registers her game's name, backend URL and e-mail with the NetMap server, and
  receives an application ID and secret.
}
\label{table:metrics-app}
\end{table}

\subsection{The Sample Game Code}

\begin{figure}[hbtp]
  \center{\includegraphics[width=85mm]{figures/gamedev.pdf}}
  \caption{
    The sample game server and client
  }
  \label{fig:sample}
\end{figure}

